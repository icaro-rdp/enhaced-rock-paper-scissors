#N canvas 1917 9 1920 944 10;
#X msg 40 228 close;
#X obj 23 -156 cnv 15 440 60 empty empty empty 20 12 0 14 #c0d828 #404040 0;
#X msg 29 201 devices;
#X floatatom 89 209 5 0 0 0 - - - 0;
#X msg 89 228 open \$1;
#X text 31 -148 [serial_print]: abstraction that works with Arduinos' Serial.print() and Serial.println() functions (with the use of [comport]);
#X text 526 -87 Inlets:;
#X text 566 -70 1st: bytes from [comport];
#X text 526 -4 Outlets:;
#X obj 29 315 s;
#X floatatom 29 395 5 0 0 0 - - - 0;
#X floatatom 69 395 5 0 0 0 - - - 0;
#X floatatom 110 395 5 0 0 0 - - - 0;
#X text 527 -144 Arguments: delimiter type (tab \, space \, comma \, any). You can provide up to two arguments (cause three arguments is the same as "any"). if no argument is provided \, then all three symbols will work as delimiters;
#X text 566 -55 2nd: change delimiter type with a symbol (as with the arguments \, you can use two delimiters separated by a space \, e.g. "tab comma");
#X obj 29 371 unpack f f f;
#X obj 159 371 unpack f f f;
#X obj 159 394 tgl 15 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 199 394 tgl 15 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 240 394 tgl 15 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X text 26 -92 [serial_print] is a vanilla abstraction that works with [comport] and Arduino's Serial.print() and Serial.println() functions.;
#N canvas 37 103 505 369 another_way_to_use_it 0;
#X msg 49 140 close;
#X msg 38 91 devices;
#X floatatom 128 121 5 0 0 0 - - - 0;
#X msg 128 140 open \$1;
#X obj 38 183 comport;
#X obj 38 227 list prepend;
#X obj 38 249 list trim;
#X floatatom 38 317 5 0 0 0 - - - 0;
#X floatatom 78 317 5 0 0 0 - - - 0;
#X floatatom 119 317 5 0 0 0 - - - 0;
#X obj 38 295 unpack f f f;
#X obj 162 295 unpack f f f;
#X obj 162 316 tgl 15 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 202 316 tgl 15 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 243 316 tgl 15 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X text 36 43 Instead of [send] and [receive] \, you can also use [route] \, but the [send]/[receive] technique might be a bit more intuitive...;
#X text 38 13 Close [comport] on the parent patch before attempting to open this one.;
#X obj 38 271 route Analog_values: Digital_values:;
#X obj 38 205 serial_print any;
#X obj 49 118 loadbang;
#X connect 0 0 4 0;
#X connect 1 0 4 0;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X connect 4 0 18 0;
#X connect 5 0 6 0;
#X connect 6 0 17 0;
#X connect 10 0 7 0;
#X connect 10 1 8 0;
#X connect 10 2 9 0;
#X connect 11 0 12 0;
#X connect 11 1 13 0;
#X connect 11 2 14 0;
#X connect 17 0 10 0;
#X connect 17 1 11 0;
#X connect 18 0 5 0;
#X connect 18 1 5 1;
#X connect 19 0 0 0;
#X restore 30 489 pd another_way_to_use_it;
#X text 26 67 This help patch works with the serial_print.ino sketch. Check it for more information.;
#X text 570 14 1st: list of values of a group.;
#X text 569 35 2nd: string to be used as a tag for a value group (print this first from the Arduino so that it works \, otherwise you'll probably get strange results). This comes out first \, then the value list out the left outlet;
#X obj 159 347 r Digital_values:;
#X text 26 -50 You can use commas \, spaces or tabs in between values to separate them. You can choose your delimiter via an argument (tab \, space \, comma or any \, or no argument which is the same as any). A string must precede a value group \, which will be used as a tag \, sent to the right inlet of [send] \, and used as an argument to the corresponding [receive]. The last value of each group must be printed with Serial.println() \, in order for [serial_print] to know a value group has ended.;
#N canvas 197 82 892 524 receive_floats_strings_and_bangs 0;
#X obj 72 24 vradio 15 1 0 5 empty empty empty 0 -8 0 10 #fcfcfc #000000 #000000 0;
#X obj 72 184 serial_print;
#X obj 72 206 s;
#X symbolatom 186 255 0 0 0 0 - - - 0;
#X obj 72 162 comport;
#X obj 100 110 loadbang;
#X msg 100 132 close;
#X floatatom 165 111 5 0 0 0 - - - 0;
#X msg 165 130 open \$1;
#X text 90 53 outputs a bang;
#X text 90 37 outputs a string;
#X floatatom 72 256 0 0 0 0 - - - 0;
#X text 90 21 outputs a float;
#X text 90 69 outputs a negative number;
#X floatatom 432 256 0 0 0 0 - - - 0;
#X text 90 83 outputs a mixed list;
#X obj 432 234 r negative_float;
#X obj 314 234 r a_bang;
#X obj 562 234 r mixed_list;
#X floatatom 562 456 0 0 0 0 - - - 0;
#X floatatom 601 431 0 0 0 0 - - - 0;
#X obj 562 408 unpack;
#X obj 613 279 print bang_in_list;
#X obj 562 256 route list bang;
#X obj 562 372 route a_string_in_a_list another_list_string last_list_string;
#X floatatom 663 456 0 0 0 0 - - - 0;
#X floatatom 702 431 0 0 0 0 - - - 0;
#X obj 663 408 unpack;
#X floatatom 765 456 0 0 0 0 - - - 0;
#X floatatom 804 431 0 0 0 0 - - - 0;
#X obj 765 408 unpack;
#X obj 614 316 list split 1;
#X symbolatom 614 338 0 0 0 0 - - - 0;
#X obj 562 299 t a a;
#X obj 314 256 print a_bang;
#X obj 72 234 r a_float;
#X obj 186 233 r a_string;
#X text 442 36 With [serial_print] it's possible to receive floats \, strings \, negative values \, or even bangs. All these types can be included in a list. A bang though \, since it can't be included in a list \, will always be output last \, no matter where it is placed in the Arduino code. Close [comport] in the parent patch and load the float_string_bang.ino sketch to your Arduino board. Then open its serial port in this subpatch and click on the radio buttons below.;
#X text 442 158 Note: [receive] arguments like "symbol" or "float" are possible \, but in general it's probably not a very good idea to use them since these words have a special meaning in Pd.;
#X connect 0 0 4 0;
#X connect 1 0 2 0;
#X connect 1 1 2 1;
#X connect 4 0 1 0;
#X connect 5 0 6 0;
#X connect 6 0 4 0;
#X connect 7 0 8 0;
#X connect 8 0 4 0;
#X connect 16 0 14 0;
#X connect 17 0 34 0;
#X connect 18 0 23 0;
#X connect 21 0 19 0;
#X connect 21 1 20 0;
#X connect 23 0 33 0;
#X connect 23 1 22 0;
#X connect 24 0 21 0;
#X connect 24 1 27 0;
#X connect 24 2 30 0;
#X connect 27 0 25 0;
#X connect 27 1 26 0;
#X connect 30 0 28 0;
#X connect 30 1 29 0;
#X connect 31 0 32 0;
#X connect 33 0 24 0;
#X connect 33 1 31 0;
#X connect 35 0 11 0;
#X connect 36 0 3 0;
#X restore 30 515 pd receive_floats_strings_and_bangs;
#X obj 29 293 serial_print any;
#X text 27 108 Note: the digital pins are using the internal pull-up resistors \, using INPUT_PULLUP \, so you don't need to use resistors for switches. For this reason the readings of the digital pins are inverted so you get a 0 when you press a switch and a 1 when you release it.;
#X obj 29 347 r Analog_values:;
#X obj 999 -158 cnv 15 1000 370 empty empty empty 20 12 0 14 #fcfcc4 #404040 0;
#X obj 1089 70 vsl 15 128 0 5 0 0 empty empty empty 0 -9 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 1032 -81 unpack s f;
#X floatatom 1089 24 8 0 0 0 - - - 0;
#X obj 1150 -110 r resolution;
#X floatatom 1150 -51 5 0 0 0 - - - 0;
#X obj 1608 54 vsl 15 128 0 1 0 0 empty empty empty 0 -9 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 1551 -99 unpack s f;
#X floatatom 1608 -36 8 0 0 0 - - - 0;
#X obj 1669 -127 r resolution;
#X floatatom 1669 -105 5 0 0 0 - - - 0;
#X obj 1032 -110 r a0;
#X obj 1133 69 s _a0;
#X obj 1551 -127 r a5;
#X obj 1649 -5 s _a5;
#X obj 1001 263 cnv 15 500 370 empty empty empty 20 12 0 14 #c4fcc4 #404040 0;
#X obj 1046 342 unpack s f;
#X obj 1103 366 tgl 30 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 1280 347 unpack s f;
#X obj 1337 371 tgl 30 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 2261 334 unpack s f;
#X obj 2318 358 tgl 30 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 1046 314 r d0;
#X obj 1280 319 r d1;
#X obj 2261 306 r d2;
#X obj 1058 379 s _d0;
#X obj 1295 384 s _d1;
#X obj 2277 371 s _d2;
#X text 1061 272 Data from digital sensors;
#X text 1043 -151 Data from analog sensors;
#X obj 643 257 cnv 15 250 370 empty empty empty 20 12 0 14 #dcdcdc #404040 0;
#X floatatom 660 406 5 0 0 0 - - - 0;
#X obj 660 429 s resolution;
#X msg 682 380 4095;
#X msg 660 351 1023;
#X obj 660 324 loadbang;
#X text 721 349 10-bit Arduino resolution;
#X text 721 379 12-bit Teensy resolution;
#X text 659 278 Configuration;
#X obj 1608 -64 cyclone/scale 0 4095 0 1 1;
#X text 32 597 NOTE: You need to wait a bit for the IMU to be calibrated. Then the stream of sensor values arrives;
#X obj 29 270 comport 1 115200;
#X msg 193 217 3;
#X text 1556 -149 Analog sensor receiver template;
#X floatatom 1089 -45 5 0 0 0 - - - 0;
#X obj 1324 74 vsl 15 128 0 5 0 0 empty empty empty 0 -9 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 1267 -77 unpack s f;
#X floatatom 1324 28 8 0 0 0 - - - 0;
#X obj 1385 -106 r resolution;
#X floatatom 1385 -47 5 0 0 0 - - - 0;
#X floatatom 1324 -41 5 0 0 0 - - - 0;
#X obj 1267 -106 r a1;
#X obj 1368 73 s _a1;
#X obj 193 186 loadbang;
#X obj 1089 -10 cyclone/scale 0 500 0 5 1;
#X obj 1324 -6 cyclone/scale 0 500 0 5 1;
#X connect 0 0 72 0;
#X connect 2 0 72 0;
#X connect 3 0 4 0;
#X connect 4 0 72 0;
#X connect 15 0 10 0;
#X connect 15 1 11 0;
#X connect 15 2 12 0;
#X connect 16 0 17 0;
#X connect 16 1 18 0;
#X connect 16 2 19 0;
#X connect 25 0 16 0;
#X connect 28 0 9 0;
#X connect 28 1 9 1;
#X connect 30 0 15 0;
#X connect 33 1 75 0;
#X connect 34 0 43 0;
#X connect 34 0 32 0;
#X connect 35 0 36 0;
#X connect 36 0 85 2;
#X connect 38 1 70 0;
#X connect 39 0 45 0;
#X connect 39 0 37 0;
#X connect 40 0 41 0;
#X connect 41 0 70 2;
#X connect 42 0 33 0;
#X connect 44 0 38 0;
#X connect 47 1 48 0;
#X connect 47 1 56 0;
#X connect 49 1 50 0;
#X connect 49 1 57 0;
#X connect 51 1 52 0;
#X connect 51 1 58 0;
#X connect 53 0 47 0;
#X connect 54 0 49 0;
#X connect 55 0 51 0;
#X connect 62 0 63 0;
#X connect 64 0 62 0;
#X connect 65 0 62 0;
#X connect 66 0 65 0;
#X connect 70 0 39 0;
#X connect 72 0 28 0;
#X connect 73 0 3 0;
#X connect 75 0 85 0;
#X connect 77 1 81 0;
#X connect 78 0 76 0;
#X connect 78 0 83 0;
#X connect 79 0 80 0;
#X connect 80 0 86 2;
#X connect 81 0 86 0;
#X connect 82 0 77 0;
#X connect 84 0 73 0;
#X connect 85 0 34 0;
#X connect 86 0 78 0;
